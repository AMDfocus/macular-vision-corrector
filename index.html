<!--
  Macular Vision Corrector
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Macular Vision Corrector</title>
<style>
  body { margin:0; padding:0; font-family:sans-serif; display:flex; flex-direction:column; align-items:center; }
  h2 { margin:16px 0; font-size:32px; }
  .canvas-container { display:flex; gap:40px; margin-bottom:16px; }
  .panel { display:flex; flex-direction:column; align-items:center; }
  canvas { border:1px solid #888; }
  button, label, textarea { font-size:16px; margin:4px; }
  #controls { display:flex; gap:8px; align-items:center; margin-bottom:16px; }
  textarea { width:400px; height:60px; font-size:18px; }
</style>
</head>
<body>
  <h2>Macular Vision Corrector</h2>
  <div class="canvas-container">
    <div class="panel">
      <h4>Calibration Grid</h4>
      <canvas id="gridCanvas" width="600" height="600"></canvas>
      <div>
        <button id="undoBtn">Undo</button>
        <button id="resetBtn">Reset Grid</button>
      </div>
    </div>
    <div class="panel">
      <h4>Corrected Text Preview</h4>
      <canvas id="previewCanvas" width="600" height="300"></canvas>
      <div>
        <label><input type="checkbox" id="centerDotChk"> Show word center dots</label>
      </div>
    </div>
  </div>
  <div id="controls">
    <textarea id="textInput">Sample Text for AMD Correction</textarea>
    <button id="applyBtn">Apply My Correction</button>
  </div>
<script>
// Element refs
const gridCanvas = document.getElementById('gridCanvas'), gctx = gridCanvas.getContext('2d');
const previewCanvas = document.getElementById('previewCanvas'), pctx = previewCanvas.getContext('2d');
const undoBtn = document.getElementById('undoBtn'), resetBtn = document.getElementById('resetBtn');
const applyBtn = document.getElementById('applyBtn'), textInput = document.getElementById('textInput');
const centerDotChk = document.getElementById('centerDotChk');
// auto re-apply correction when toggling center dots
centerDotChk.addEventListener('change', () => applyBtn.onclick());

// Grid settings
const COLS = 20, N = COLS + 1;
const gridSize = 600;
const cellW = gridSize / COLS, cellH = cellW;
const FONT = '28px sans-serif', LINEH = 32;

// State
let points = [], dragPoint = null;
for (let i = 0; i < N; i++) {
  points[i] = [];
  for (let j = 0; j < N; j++) {
    points[i][j] = { x: i * cellW, y: j * cellH, dx: 0, dy: 0 };
  }
}

// Draw grid
function drawGrid() {
  gctx.clearRect(0, 0, gridSize, gridSize);
  gctx.strokeStyle = '#ccc'; gctx.lineWidth = 1;
  // Vertical
  for (let i = 0; i < N; i++) {
    gctx.beginPath();
    gctx.moveTo(points[i][0].x + points[i][0].dx, points[i][0].y + points[i][0].dy);
    for (let j = 1; j < N; j++) {
      gctx.lineTo(points[i][j].x + points[i][j].dx, points[i][j].y + points[i][j].dy);
    }
    gctx.stroke();
  }
  // Horizontal
  for (let j = 0; j < N; j++) {
    gctx.beginPath();
    gctx.moveTo(points[0][j].x + points[0][j].dx, points[0][j].y + points[0][j].dy);
    for (let i = 1; i < N; i++) {
      gctx.lineTo(points[i][j].x + points[i][j].dx, points[i][j].y + points[i][j].dy);
    }
    gctx.stroke();
  }
  // Dots & center
  points.flat().forEach(p => {
    gctx.beginPath(); gctx.arc(p.x + p.dx, p.y + p.dy, 5, 0, 2 * Math.PI);
    gctx.fillStyle = '#333'; gctx.fill();
  });
  const cx = gridSize / 2, cy = gridSize / 2;
  gctx.strokeStyle = 'red'; gctx.lineWidth = 2;
  gctx.beginPath(); gctx.arc(cx, cy, 8, 0, 2 * Math.PI); gctx.stroke();
  gctx.beginPath();
  gctx.moveTo(cx - 15, cy); gctx.lineTo(cx + 15, cy);
  gctx.moveTo(cx, cy - 15); gctx.lineTo(cx, cy + 15);
  gctx.stroke();
}

// Undo/Reset
const history = [];
function saveState() { history.push(points.flat().map(p => ({ dx: p.dx, dy: p.dy }))); }
undoBtn.onclick = () => { if (history.length) { const last = history.pop(); points.flat().forEach((p,i) => { p.dx = last[i].dx; p.dy = last[i].dy; }); drawGrid(); }};
resetBtn.onclick = () => { points.flat().forEach(p => { p.dx = 0; p.dy = 0; }); history.length = 0; drawGrid(); pctx.clearRect(0,0,previewCanvas.width, previewCanvas.height); };

// Drag
gridCanvas.addEventListener('pointerdown', e => { saveState(); const r = gridCanvas.getBoundingClientRect(); const mx = e.clientX - r.left, my = e.clientY - r.top; points.flat().forEach(p => { if (Math.hypot(mx - (p.x + p.dx), my - (p.y + p.dy)) < 8) dragPoint = p; }); });
gridCanvas.addEventListener('pointermove', e => { if (!dragPoint) return; const r = gridCanvas.getBoundingClientRect(); dragPoint.dx = e.clientX - r.left - dragPoint.x; dragPoint.dy = e.clientY - r.top - dragPoint.y; drawGrid(); });
gridCanvas.addEventListener('pointerup', () => { dragPoint = null; });

// Fourier & Apply (omitted for brevity)

// Init
drawGrid();
</script>
</body>
</html>
